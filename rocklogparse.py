# Jade Chongsathapornpong, June 2023
"""
These are functions for reading logs generated by the ROCK beamline XRD/XAS measurement setup,
used specifically by Isabelle Maurin. The logs were mostly auto-generated, and are not
in machine-readable format, which is why this mess exists.
It is unlikely the code will generalize to anything else.
"""

import datetime
import csv
import re

##### General Logbook Parsing #####

def read_column_log(log_file, indices, skiprows=2):
    """ NOT PREFERRED. When available, use pandas read instead. This was made to deal with a specific
    problem in the ROCK logger, wherein the columns were space-delimited but had a column
    whose entries (human-readable date) contained spaces themselves.
    Args:
        - path (str): to a space-delimited column-structured log file as generated by some logger at ROCK
    Returns:
        - (list of lists of ) data"""
    with open(log_file, 'r') as f:
        entries = f.readlines()[skiprows:]
    split_entries = [row_string.split(' ') for row_string in entries]
    ret = [[float(row[idx]) for idx in indices] for row in split_entries]
    return ret

def separate_entries(path, skiplines, delimiter=''):
    """Args:
        - path (str): to a human-readable formatted logbook file, text format
        - skiplines (int): to skip the header of the logbook
        - delimiter (str): contents of the line that separates entries
            after applying .strip(); e.g. '' for an empty line
    Returns:
        - (list of lists of str) One list each logbook entry, containing lines as strings."""
    with open(path, 'r') as lxf:
        raw_lines = lxf.readlines()[skiplines:]
        lines = [line.strip() for line in raw_lines]
    entries = []
    buffer = []
    for line in lines:
        if line == delimiter and len(buffer) > 0:
            entries.append(buffer.copy())
            buffer.clear()
            continue
        if len(line) > 0:
            buffer.append(line)
    return entries

def create_filename_dictionary(metadata, key_func):
    """Args:
        - metadata (iterable of iterable): list of containers (e.g. tuples) of log entry metadata,
            for example as returned by extract_logbook_XRD_metadata or (...)
        - key_func (callable): function taking a tuple or list and returning a unique key value.
            If the returned key is None, then the entry will not be added to the return dictionary.
    Returns:
        - (dictionary) of keys, with the corresponding metadata being the value"""
    ret = dict()
    for entry in metadata:
        key = key_func(entry)
        if key is not None:
            ret[key] = entry
    return ret
        

##### XRD Logbook Parsing

def extract_logbook_XRD_metadata(entries):
    """Args:
        - entries (list of lists of str): as returned by separate_entries
            on a speck3-generated logbook file
    Returns:
        - (list of tuple) A list, corresponding to the entries processed, containing
            the (file path, sample temp. initial, sample temp. final, 
                    time initial, time final, monochromator eV)"""
    
    metadata = []
    for entry in entries:
        # the strings corresponding to each
        path = entry[1]
        
        temperatures = entry[3]
        Ti = float(re.findall(r'\d+.\d+', temperatures[:len(temperatures)//2])[0])
        Tf = float(re.findall(r'\d+.\d+', temperatures[len(temperatures)//2:])[0])
                   
        times = entry[4]
        ti = float(re.findall(r'\d+.\d+', times[:len(times)//2])[0])
        tf = float(re.findall(r'\d+.\d+', times[len(times)//2:])[0])
        
        eV = float(re.findall(r'\d+.\d+', entry[5])[0])
                                  
        metadata.append((path, Ti, Tf, ti, tf, eV))
    return metadata